#define _GNU_SOURCE

#include "integralmgr.h"

#include <stdlib.h>
#include <string.h>
#include <assert.h>
#include <stdio.h>
#include <pthread.h>

#include "db.h"

struct Target {
	QsIntegral integral;
	bool master;
};

struct Databases {
	QsDb read;
	QsDb readwrite;
};

struct Substitution {
	char* name;
	char* value;
};

struct QsIntegralMgr {
	unsigned n_integrals;
	unsigned allocated;
	struct Target* integrals;

	char* ro_prefix;
	char* ro_suffix;

	char* rw_prefix;
	char* rw_suffix;

	unsigned n_dbs;
	struct Databases** dbs;

	unsigned n_substitutions;
	struct Substitution* substitutions;
};

static struct Databases open_db( QsIntegralMgr m,QsPrototype p,bool create_rw ) {
	if( !( p<m->n_dbs ) ) {
		m->dbs = realloc( m->dbs,( p + 1 )*sizeof (struct Databases*) );
		int j;
		for( j = m->n_dbs; j<p + 1; j++ )
			m->dbs[ j ]= NULL;
		m->n_dbs = p + 1;
	}

	bool new;
	if( ( new = !m->dbs[ p ] ) ) {
		m->dbs[ p ]= malloc( sizeof (struct Databases) );

		char* filename;
		asprintf( &filename,"%s%i%s",m->ro_prefix,p,m->ro_suffix );
		m->dbs[ p ]->read = qs_db_new( filename,QS_DB_READ );
		free( filename );
	}

	if( new || ( !m->dbs[ p ]->readwrite && create_rw ) ) {
		char* filename;
		asprintf( &filename,"%s%i%s",m->rw_prefix,p,m->rw_suffix );
		m->dbs[ p ]->readwrite = qs_db_new( filename,QS_DB_WRITE|( create_rw?QS_DB_CREATE:0 ) );
		free( filename );
	}

	return *( m->dbs[ p ] );
}

void qs_integral_mgr_add_substitution( QsIntegralMgr m,char* symbol,char* value ) {
	m->substitutions = realloc( m->substitutions,++( m->n_substitutions )*sizeof (struct Substitution) );
	m->substitutions[ m->n_substitutions - 1 ]= (struct Substitution){ strdup( symbol ),strdup( value ) };
}

/** Load and save
 *
 * QsIntegralMgr loads and saves data in a downwards compatible manner
 * to IdSolver. In particular, this refers to different formats of the
 * identity entries in the databases.
 *
 * Identity Database, generated by IdSolver, "idPR#.dat"
 * - Expression with order
 * - Empty expression with order
 *
 * Solution Database, generated and modified by possibly both, "PR#.dat":
 * - Expression
 * - Empty expression
 * - Expression with metadata
 *
 * The structure of an Expression is
 *
 * <Expression> := <Term>*
 * <Term> := <Int Size:int> <Integral> <Coeff Size:int> <Coeff:char[]>
 * <Integral> := <Prototype:char[]> '\0' <Powers>
 * <Powers> := <Power:char>*
 *
 * whereas an empty expression is just a 0 byte
 *
 * <Empty Expression> := '\0'
 *
 * With those definitions, we further have
 *
 * <Expression with order> := <Expression> <Order:int>
 * <Empty expression with order> := <Empty expression> <Order:int>
 * 
 * Since every <Term> is at least 2 time the size of an int, we have the
 * option to enhance any <Expression> by 2 integers less a single byte
 * (7 bytes).
 * This additional data constitutes the <Metadata>, used by Quicksolve.
 * Contrary to IdSolver then, which only stores expression for assigned
 * integrals in the solution database and may therefore omit that
 * integral's order (because it will not be relevant once an integral
 * has been solved), Quicksolve may store identities at any intermediate
 * stage of the solution, storing transient data alongside.
 *
 * When loading an identity, we can then distinguish between the two
 * formats by parsing the expression, which will detect that it can't
 * extend beyond the current point if only 3 bytes are left. When this
 * happens (i.e. 7 bytes are left after the end of the expression), we
 * know that we're dealing with an <Expression with metadata>.
 *
 * Currently, the seven bytes metadata are assigned as
 *
 * <Metadata> = <Order:int> <Solved:char> '\0' '\0'
 *
 * Expressions with metadata are interpreted as identities as-is, as are
 * Expressions with order. Empty expressions with and without order as
 * well as Expressions without metadata in the solution database are
 * interpreted as the given expression -1 times the integral to which is
 * is associated. * 
 */

void qs_integral_mgr_save_expression( QsIntegralMgr m,QsComponent i,struct QsReflist l,struct QsMetadata meta ) {
	QsExpression e = qs_expression_new_with_size( l.n_references );

	int j;
	for( j = 0; j<l.n_references; j++ )
		qs_expression_add( e,l.references[ j ].coefficient,qs_integral_mgr_peek( m,l.references[ j ].head ) );

	QsIntegral in = qs_integral_mgr_peek( m,i );

	struct Databases dbs = open_db( m,qs_integral_prototype( in ),true );

	struct QsDbEntry* entry = malloc( sizeof (struct QsDbEntry) );
	entry->keylen = qs_integral_n_powers( in )*sizeof (QsPower);
	entry->key = malloc( entry->keylen );
	memcpy( entry->key,qs_integral_powers( in ),entry->keylen );
	unsigned expression_size = qs_expression_to_binary( e,&entry->val );
	entry->vallen = expression_size + QS_METADATA_SIZE;
	entry->val = realloc( entry->val,entry->vallen );
	*( (int*)( entry->val + expression_size ) )= meta.order;
	*( (char*)( entry->val + expression_size + sizeof (int) ) )= meta.solved?1:0;

	qs_db_set( dbs.readwrite,entry );

	qs_db_entry_destroy( entry );

	qs_expression_disband( e );
}

struct QsReflist qs_integral_mgr_load_expression( QsIntegralMgr m,QsComponent i,struct QsMetadata* meta ) {
	struct QsReflist result ={ 0,NULL };

	if( m->integrals[ i ].master )
		return result;

	QsIntegral in = m->integrals[ i ].integral;
	QsPrototype p = qs_integral_prototype( in );

	QsExpression e = NULL;
	bool sub_self = false;
	struct Databases dbs = open_db( m,p,false );

	unsigned n_powers = qs_integral_n_powers( in );
	const QsPower* pwrs = qs_integral_powers( in );
	unsigned keylen = n_powers*sizeof (QsPower);
	struct QsDbEntry* data;

	if( dbs.readwrite &&( data = qs_db_get( dbs.readwrite,(char*)pwrs,keylen ) ) ) {
		/* Obtain identity from solution database */
		unsigned n;
		e = qs_expression_new_from_binary( data->val,data->vallen,&n );

		if( data->vallen>=n+QS_METADATA_SIZE ) {
			meta->order = *( (int*)( data->val + n ) );
			meta->solved = *( (char*)( data->val + n + sizeof (int) ) )!='\0';
		} else {
			meta->order = 0;
			meta->solved = true;
			sub_self = true;
		}

		meta->solving = false;

		qs_db_entry_destroy( data );
	} else if( dbs.read &&( data = qs_db_get( dbs.read,(char*)pwrs,keylen ) ) ) {
		/* Obtain identity from identity database */
		e = qs_expression_new_from_binary( data->val,data->vallen,NULL );
		meta->order = *( (int*)( data->val + data->vallen - sizeof (int) ) );
		meta->solved = false;
		meta->solving = false;

		if( e )
			if( qs_expression_n_terms( e )==1 && qs_coefficient_is_one( qs_expression_coefficient( e,0 ) ) )
				sub_self = true;

		qs_db_entry_destroy( data );
	} else {
		m->integrals[ i ].master = true;
		return result;
	}

	unsigned n = qs_expression_n_terms( e );

	if( n==0 || sub_self )
		result.n_references = 1 + n;
	else
		result.n_references = n;

	result.references = malloc( result.n_references*sizeof (struct QsReference) );
		
	int j;
	for( j = 0; j<n; j++ ) {
		QsIntegral integral = qs_expression_integral( e,j );
		QsCoefficient coefficient = qs_expression_coefficient( e,j );

		int k;
		for( k = 0; k<m->n_substitutions; k++ )
			qs_coefficient_substitute( coefficient,m->substitutions[ k ].name,m->substitutions[ k ].value );

		result.references[ j ].coefficient = coefficient;
		result.references[ j ].head = qs_integral_mgr_manage( m,integral );
	}

	qs_expression_disband( e );

	if( n==0 || sub_self ) {
		result.references[ j ].coefficient = qs_coefficient_one( true );
		result.references[ j ].head = i;
		if( n==0 ) {
			char* str;
			qs_integral_print( m->integrals[ i ].integral,&str );
			fprintf( stderr,"Warning: Database empty expression for %s\n",str );
			free( str );
		}
	}
	
	return result;
}

QsIntegral qs_integral_mgr_peek( QsIntegralMgr m,QsComponent i ) {
	if( !( i<m->n_integrals ) )
		return NULL;

	return m->integrals[ i ].integral;
}

QsIntegralMgr qs_integral_mgr_new_with_size( const char* ro_prefix,const char* ro_suffix,const char* rw_prefix,const char* rw_suffix,unsigned prealloc ) {
	QsIntegralMgr result = malloc( sizeof (struct QsIntegralMgr) );
	result->n_integrals = 0;
	result->allocated = prealloc;
	result->integrals = malloc( prealloc*sizeof (struct Target) );
	result->ro_prefix = strdup( ro_prefix );
	result->ro_suffix = strdup( ro_suffix );
	result->rw_prefix = strdup( rw_prefix );
	result->rw_suffix = strdup( rw_suffix );

	result->n_dbs = 0;
	result->dbs = malloc( 0 );

	result->n_substitutions = 0;
	result->substitutions = malloc( 0 );

	return result;
}

/** Take responsibility of the integral
 *
 * Takes ownership of the integral and will return a unique pointer to
 * that integral.
 *
 * @param This
 * @param[transfer full] The integral to manage
 * @return The uniquely assigned Id of the Integral
 */
QsComponent qs_integral_mgr_manage( QsIntegralMgr g,QsIntegral i ) {
	int j = 0;
	while( j<g->n_integrals && qs_integral_cmp( g->integrals[ j ].integral,i ) )
		j++;

	if( j==g->n_integrals ) {
		if( g->allocated==g->n_integrals )
			g->integrals = realloc( g->integrals,++( g->allocated )*sizeof (struct Target) );
		g->integrals[ j ].integral = i;
		g->integrals[ j ].master = false;
		g->n_integrals++;
	} else {
		/* If we're told to manage the very integral that we gave to you or
		 * that you previously told us to manage, you're doing something
		 * ugly */
		assert( g->integrals[ j ].integral!=i );
		qs_integral_destroy( i );
	}

	return j;
}

void qs_integral_mgr_destroy( QsIntegralMgr m ) {
	int j;
	for( j = 0; j<m->n_integrals; j++ )
		qs_integral_destroy( m->integrals[ j ].integral );

	for( j = 0; j<m->n_dbs; j++ ) {
		struct Databases* dbs = m->dbs[ j ];
		if( dbs ) {
			if( dbs->read )
				qs_db_destroy( dbs->read );
			if( dbs->readwrite )
				qs_db_destroy( dbs->readwrite );

			free( dbs );
		}
	}

	for( j = 0; j<m->n_substitutions; j++ ) {
		free( m->substitutions[ j ].name );
		free( m->substitutions[ j ].value );
	}

	free( m->substitutions );
	free( m->integrals );
	free( m->ro_prefix );
	free( m->ro_suffix );
	free( m->rw_prefix );
	free( m->rw_suffix );
	free( m->dbs );
	free( m );
}
